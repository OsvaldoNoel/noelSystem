import{equalizePoints,getDistanceBetween,clamp,pointsEqual}from"../util/util.js";const UPPER_ZOOM_FRICTION=.05,LOWER_ZOOM_FRICTION=.15;function getZoomPointsCenter(t,o,e){return t.x=(o.x+e.x)/2,t.y=(o.y+e.y)/2,t}class ZoomHandler{constructor(t){this.gestures=t,this._startPan={x:0,y:0},this._startZoomPoint={x:0,y:0},this._zoomPoint={x:0,y:0},this._wasOverFitZoomLevel=!1,this._startZoomLevel=1}start(){const{currSlide:t}=this.gestures.pswp;t&&(this._startZoomLevel=t.currZoomLevel,equalizePoints(this._startPan,t.pan)),this.gestures.pswp.animations.stopAllPan(),this._wasOverFitZoomLevel=!1}change(){const{p1:t,startP1:o,p2:e,startP2:s,pswp:i}=this.gestures,{currSlide:n}=i;if(!n)return;const a=n.zoomLevels.min,l=n.zoomLevels.max;if(!n.isZoomable()||i.mainScroll.isShifted())return;getZoomPointsCenter(this._startZoomPoint,o,s),getZoomPointsCenter(this._zoomPoint,t,e);let r=1/getDistanceBetween(o,s)*getDistanceBetween(t,e)*this._startZoomLevel;if(r>n.zoomLevels.initial+n.zoomLevels.initial/15&&(this._wasOverFitZoomLevel=!0),r<a)if(i.options.pinchToClose&&!this._wasOverFitZoomLevel&&this._startZoomLevel<=n.zoomLevels.initial){const t=1-(a-r)/(a/1.2);i.dispatch("pinchClose",{bgOpacity:t}).defaultPrevented||i.applyBgOpacity(t)}else r=a-.15*(a-r);else r>l&&(r=l+.05*(r-l));n.pan.x=this._calculatePanForZoomLevel("x",r),n.pan.y=this._calculatePanForZoomLevel("y",r),n.setZoomLevel(r),n.applyCurrentZoomPan()}end(){const{pswp:t}=this.gestures,{currSlide:o}=t;(!o||o.currZoomLevel<o.zoomLevels.initial)&&!this._wasOverFitZoomLevel&&t.options.pinchToClose?t.close():this.correctZoomPan()}_calculatePanForZoomLevel(t,o){const e=o/this._startZoomLevel;return this._zoomPoint[t]-(this._startZoomPoint[t]-this._startPan[t])*e}correctZoomPan(t){const{pswp:o}=this.gestures,{currSlide:e}=o;if(!e?.isZoomable())return;0===this._zoomPoint.x&&(t=!0);const s=e.currZoomLevel;let i,n=!0;s<e.zoomLevels.initial?i=e.zoomLevels.initial:s>e.zoomLevels.max?i=e.zoomLevels.max:(n=!1,i=s);const a=o.bgOpacity,l=o.bgOpacity<1,r=equalizePoints({x:0,y:0},e.pan);let m=equalizePoints({x:0,y:0},r);t&&(this._zoomPoint.x=0,this._zoomPoint.y=0,this._startZoomPoint.x=0,this._startZoomPoint.y=0,this._startZoomLevel=s,equalizePoints(this._startPan,r)),n&&(m={x:this._calculatePanForZoomLevel("x",i),y:this._calculatePanForZoomLevel("y",i)}),e.setZoomLevel(i),m={x:e.bounds.correctPan("x",m.x),y:e.bounds.correctPan("y",m.y)},e.setZoomLevel(s);const c=!pointsEqual(m,r);if(!c&&!n&&!l)return e._setResolution(i),void e.applyCurrentZoomPan();o.animations.stopAllPan(),o.animations.startSpring({isPan:!0,start:0,end:1e3,velocity:0,dampingRatio:1,naturalFrequency:40,onUpdate:t=>{if(t/=1e3,c||n){if(c&&(e.pan.x=r.x+(m.x-r.x)*t,e.pan.y=r.y+(m.y-r.y)*t),n){const o=s+(i-s)*t;e.setZoomLevel(o)}e.applyCurrentZoomPan()}l&&o.bgOpacity<1&&o.applyBgOpacity(clamp(a+(1-a)*t,0,1))},onComplete:()=>{e._setResolution(i),e.applyCurrentZoomPan()}})}}export default ZoomHandler;