import Graphics from"./Graphics";import Utils from"./../utils/Utils";import Toolbar from"./Toolbar";import Scales from"./Scales";export default class ZoomPanSelection extends Toolbar{constructor(t){super(t),this.ctx=t,this.w=t.w,this.dragged=!1,this.graphics=new Graphics(this.ctx),this.eventList=["mousedown","mouseleave","mousemove","touchstart","touchmove","mouseup","touchend"],this.clientX=0,this.clientY=0,this.startX=0,this.endX=0,this.dragX=0,this.startY=0,this.endY=0,this.dragY=0,this.moveDirection="none"}init({xyRatios:t}){let e=this.w,i=this;this.xyRatios=t,this.zoomRect=this.graphics.drawRect(0,0,0,0),this.selectionRect=this.graphics.drawRect(0,0,0,0),this.gridRect=e.globals.dom.baseEl.querySelector(".apexcharts-grid"),this.zoomRect.node.classList.add("apexcharts-zoom-rect"),this.selectionRect.node.classList.add("apexcharts-selection-rect"),e.globals.dom.elGraphical.add(this.zoomRect),e.globals.dom.elGraphical.add(this.selectionRect),"x"===e.config.chart.selection.type?this.slDraggableRect=this.selectionRect.draggable({minX:0,minY:0,maxX:e.globals.gridWidth,maxY:e.globals.gridHeight}).on("dragmove",this.selectionDragging.bind(this,"dragging")):"y"===e.config.chart.selection.type?this.slDraggableRect=this.selectionRect.draggable({minX:0,maxX:e.globals.gridWidth}).on("dragmove",this.selectionDragging.bind(this,"dragging")):this.slDraggableRect=this.selectionRect.draggable().on("dragmove",this.selectionDragging.bind(this,"dragging")),this.preselectedSelection(),this.hoverArea=e.globals.dom.baseEl.querySelector(`${e.globals.chartClass} .apexcharts-svg`),this.hoverArea.classList.add("apexcharts-zoomable"),this.eventList.forEach((e=>{this.hoverArea.addEventListener(e,i.svgMouseEvents.bind(i,t),{capture:!1,passive:!0})}))}destroy(){this.slDraggableRect&&(this.slDraggableRect.draggable(!1),this.slDraggableRect.off(),this.selectionRect.off()),this.selectionRect=null,this.zoomRect=null,this.gridRect=null}svgMouseEvents(t,e){let i=this.w,o=this;const s=this.ctx.toolbar;let a=i.globals.zoomEnabled?i.config.chart.zoom.type:i.config.chart.selection.type;const l=i.config.chart.toolbar.autoSelected;if(e.shiftKey?(this.shiftWasPressed=!0,s.enableZoomPanFromToolbar("pan"===l?"zoom":"pan")):this.shiftWasPressed&&(s.enableZoomPanFromToolbar(l),this.shiftWasPressed=!1),!e.target)return;const n=e.target.classList;let c;e.target.parentNode&&null!==e.target.parentNode&&(c=e.target.parentNode.classList);if(!(n.contains("apexcharts-selection-rect")||n.contains("apexcharts-legend-marker")||n.contains("apexcharts-legend-text")||c&&c.contains("apexcharts-toolbar"))){if(o.clientX="touchmove"===e.type||"touchstart"===e.type?e.touches[0].clientX:"touchend"===e.type?e.changedTouches[0].clientX:e.clientX,o.clientY="touchmove"===e.type||"touchstart"===e.type?e.touches[0].clientY:"touchend"===e.type?e.changedTouches[0].clientY:e.clientY,"mousedown"===e.type&&1===e.which){let t=o.gridRect.getBoundingClientRect();o.startX=o.clientX-t.left,o.startY=o.clientY-t.top,o.dragged=!1,o.w.globals.mousedown=!0}if(("mousemove"===e.type&&1===e.which||"touchmove"===e.type)&&(o.dragged=!0,i.globals.panEnabled?(i.globals.selection=null,o.w.globals.mousedown&&o.panDragging({context:o,zoomtype:a,xyRatios:t})):(o.w.globals.mousedown&&i.globals.zoomEnabled||o.w.globals.mousedown&&i.globals.selectionEnabled)&&(o.selection=o.selectionDrawing({context:o,zoomtype:a}))),"mouseup"===e.type||"touchend"===e.type||"mouseleave"===e.type){let t=o.gridRect.getBoundingClientRect();o.w.globals.mousedown&&(o.endX=o.clientX-t.left,o.endY=o.clientY-t.top,o.dragX=Math.abs(o.endX-o.startX),o.dragY=Math.abs(o.endY-o.startY),(i.globals.zoomEnabled||i.globals.selectionEnabled)&&o.selectionDrawn({context:o,zoomtype:a}),i.globals.panEnabled&&i.config.xaxis.convertedCatToNumeric&&o.delayedPanScrolled()),i.globals.zoomEnabled&&o.hideSelectionRect(this.selectionRect),o.dragged=!1,o.w.globals.mousedown=!1}this.makeSelectionRectDraggable()}}makeSelectionRectDraggable(){const t=this.w;if(!this.selectionRect)return;const e=this.selectionRect.node.getBoundingClientRect();e.width>0&&e.height>0&&this.slDraggableRect.selectize({points:"l, r",pointSize:8,pointType:"rect"}).resize({constraint:{minX:0,minY:0,maxX:t.globals.gridWidth,maxY:t.globals.gridHeight}}).on("resizing",this.selectionDragging.bind(this,"resizing"))}preselectedSelection(){const t=this.w,e=this.xyRatios;if(!t.globals.zoomEnabled)if(void 0!==t.globals.selection&&null!==t.globals.selection)this.drawSelectionRect(t.globals.selection);else if(void 0!==t.config.chart.selection.xaxis.min&&void 0!==t.config.chart.selection.xaxis.max){let i=(t.config.chart.selection.xaxis.min-t.globals.minX)/e.xRatio,o=t.globals.gridWidth-(t.globals.maxX-t.config.chart.selection.xaxis.max)/e.xRatio-i;t.globals.isRangeBar&&(i=(t.config.chart.selection.xaxis.min-t.globals.yAxisScale[0].niceMin)/e.invertedYRatio,o=(t.config.chart.selection.xaxis.max-t.config.chart.selection.xaxis.min)/e.invertedYRatio);let s={x:i,y:0,width:o,height:t.globals.gridHeight,translateX:0,translateY:0,selectionEnabled:!0};this.drawSelectionRect(s),this.makeSelectionRectDraggable(),"function"==typeof t.config.chart.events.selection&&t.config.chart.events.selection(this.ctx,{xaxis:{min:t.config.chart.selection.xaxis.min,max:t.config.chart.selection.xaxis.max},yaxis:{}})}}drawSelectionRect({x:t,y:e,width:i,height:o,translateX:s=0,translateY:a=0}){const l=this.w,n=this.zoomRect,c=this.selectionRect;if(this.dragged||null!==l.globals.selection){let r={transform:"translate("+s+", "+a+")"};l.globals.zoomEnabled&&this.dragged&&(i<0&&(i=1),n.attr({x:t,y:e,width:i,height:o,fill:l.config.chart.zoom.zoomedArea.fill.color,"fill-opacity":l.config.chart.zoom.zoomedArea.fill.opacity,stroke:l.config.chart.zoom.zoomedArea.stroke.color,"stroke-width":l.config.chart.zoom.zoomedArea.stroke.width,"stroke-opacity":l.config.chart.zoom.zoomedArea.stroke.opacity}),Graphics.setAttrs(n.node,r)),l.globals.selectionEnabled&&(c.attr({x:t,y:e,width:i>0?i:0,height:o>0?o:0,fill:l.config.chart.selection.fill.color,"fill-opacity":l.config.chart.selection.fill.opacity,stroke:l.config.chart.selection.stroke.color,"stroke-width":l.config.chart.selection.stroke.width,"stroke-dasharray":l.config.chart.selection.stroke.dashArray,"stroke-opacity":l.config.chart.selection.stroke.opacity}),Graphics.setAttrs(c.node,r))}}hideSelectionRect(t){t&&t.attr({x:0,y:0,width:0,height:0})}selectionDrawing({context:t,zoomtype:e}){const i=this.w;let o=t,s=this.gridRect.getBoundingClientRect(),a=o.startX-1,l=o.startY,n=!1,c=!1,r=o.clientX-s.left-a,g=o.clientY-s.top-l,h={};return Math.abs(r+a)>i.globals.gridWidth?r=i.globals.gridWidth-a:o.clientX-s.left<0&&(r=a),a>o.clientX-s.left&&(n=!0,r=Math.abs(r)),l>o.clientY-s.top&&(c=!0,g=Math.abs(g)),h="x"===e?{x:n?a-r:a,y:0,width:r,height:i.globals.gridHeight}:"y"===e?{x:0,y:c?l-g:l,width:i.globals.gridWidth,height:g}:{x:n?a-r:a,y:c?l-g:l,width:r,height:g},o.drawSelectionRect(h),o.selectionDragging("resizing"),h}selectionDragging(t,e){const i=this.w,o=this.xyRatios,s=this.selectionRect;let a=0;"resizing"===t&&(a=30);const l=t=>parseFloat(s.node.getAttribute(t)),n={x:l("x"),y:l("y"),width:l("width"),height:l("height")};i.globals.selection=n,"function"==typeof i.config.chart.events.selection&&i.globals.selectionEnabled&&(clearTimeout(this.w.globals.selectionResizeTimer),this.w.globals.selectionResizeTimer=window.setTimeout((()=>{const t=this.gridRect.getBoundingClientRect(),e=s.node.getBoundingClientRect();let a,l,n,c;i.globals.isRangeBar?(a=i.globals.yAxisScale[0].niceMin+(e.left-t.left)*o.invertedYRatio,l=i.globals.yAxisScale[0].niceMin+(e.right-t.left)*o.invertedYRatio,n=0,c=1):(a=i.globals.xAxisScale.niceMin+(e.left-t.left)*o.xRatio,l=i.globals.xAxisScale.niceMin+(e.right-t.left)*o.xRatio,n=i.globals.yAxisScale[0].niceMin+(t.bottom-e.bottom)*o.yRatio[0],c=i.globals.yAxisScale[0].niceMax-(e.top-t.top)*o.yRatio[0]);const r={xaxis:{min:a,max:l},yaxis:{min:n,max:c}};i.config.chart.events.selection(this.ctx,r),i.config.chart.brush.enabled&&void 0!==i.config.chart.events.brushScrolled&&i.config.chart.events.brushScrolled(this.ctx,r)}),a))}selectionDrawn({context:t,zoomtype:e}){const i=this.w,o=t,s=this.xyRatios,a=this.ctx.toolbar;if(o.startX>o.endX){let t=o.startX;o.startX=o.endX,o.endX=t}if(o.startY>o.endY){let t=o.startY;o.startY=o.endY,o.endY=t}let l,n;i.globals.isRangeBar?(l=i.globals.yAxisScale[0].niceMin+o.startX*s.invertedYRatio,n=i.globals.yAxisScale[0].niceMin+o.endX*s.invertedYRatio):(l=i.globals.xAxisScale.niceMin+o.startX*s.xRatio,n=i.globals.xAxisScale.niceMin+o.endX*s.xRatio);let c=[],r=[];if(i.config.yaxis.forEach(((t,e)=>{if(i.globals.seriesYAxisMap[e].length>0){let t=i.globals.seriesYAxisMap[e][0];c.push(i.globals.yAxisScale[e].niceMax-s.yRatio[t]*o.startY),r.push(i.globals.yAxisScale[e].niceMax-s.yRatio[t]*o.endY)}})),o.dragged&&(o.dragX>10||o.dragY>10)&&l!==n)if(i.globals.zoomEnabled){let t=Utils.clone(i.globals.initialConfig.yaxis),s=Utils.clone(i.globals.initialConfig.xaxis);if(i.globals.zoomed=!0,i.config.xaxis.convertedCatToNumeric&&(l=Math.floor(l),n=Math.floor(n),l<1&&(l=1,n=i.globals.dataPoints),n-l<2&&(n=l+1)),"xy"!==e&&"x"!==e||(s={min:l,max:n}),"xy"!==e&&"y"!==e||t.forEach(((e,i)=>{t[i].min=r[i],t[i].max=c[i]})),a){let e=a.getBeforeZoomRange(s,t);e&&(s=e.xaxis?e.xaxis:s,t=e.yaxis?e.yaxis:t)}let g={xaxis:s};i.config.chart.group||(g.yaxis=t),o.ctx.updateHelpers._updateOptions(g,!1,o.w.config.chart.animations.dynamicAnimation.enabled),"function"==typeof i.config.chart.events.zoomed&&a.zoomCallback(s,t)}else if(i.globals.selectionEnabled){let t=null,s=null;s={min:l,max:n},"xy"!==e&&"y"!==e||(t=Utils.clone(i.config.yaxis),t.forEach(((e,i)=>{t[i].min=r[i],t[i].max=c[i]}))),i.globals.selection=o.selection,"function"==typeof i.config.chart.events.selection&&i.config.chart.events.selection(o.ctx,{xaxis:s,yaxis:t})}}panDragging({context:t}){const e=this.w;let i=t;if(void 0!==e.globals.lastClientPosition.x){const t=e.globals.lastClientPosition.x-i.clientX,o=e.globals.lastClientPosition.y-i.clientY;Math.abs(t)>Math.abs(o)&&t>0?this.moveDirection="left":Math.abs(t)>Math.abs(o)&&t<0?this.moveDirection="right":Math.abs(o)>Math.abs(t)&&o>0?this.moveDirection="up":Math.abs(o)>Math.abs(t)&&o<0&&(this.moveDirection="down")}e.globals.lastClientPosition={x:i.clientX,y:i.clientY};let o=e.globals.isRangeBar?e.globals.minY:e.globals.minX,s=e.globals.isRangeBar?e.globals.maxY:e.globals.maxX;e.config.xaxis.convertedCatToNumeric||i.panScrolled(o,s)}delayedPanScrolled(){const t=this.w;let e=t.globals.minX,i=t.globals.maxX;const o=(t.globals.maxX-t.globals.minX)/2;"left"===this.moveDirection?(e=t.globals.minX+o,i=t.globals.maxX+o):"right"===this.moveDirection&&(e=t.globals.minX-o,i=t.globals.maxX-o),e=Math.floor(e),i=Math.floor(i),this.updateScrolledChart({xaxis:{min:e,max:i}},e,i)}panScrolled(t,e){const i=this.w,o=this.xyRatios;let s=Utils.clone(i.globals.initialConfig.yaxis),a=o.xRatio,l=i.globals.minX,n=i.globals.maxX;i.globals.isRangeBar&&(a=o.invertedYRatio,l=i.globals.minY,n=i.globals.maxY),"left"===this.moveDirection?(t=l+i.globals.gridWidth/15*a,e=n+i.globals.gridWidth/15*a):"right"===this.moveDirection&&(t=l-i.globals.gridWidth/15*a,e=n-i.globals.gridWidth/15*a),i.globals.isRangeBar||(t<i.globals.initialMinX||e>i.globals.initialMaxX)&&(t=l,e=n);let c={xaxis:{min:t,max:e}};i.config.chart.group||(c.yaxis=s),this.updateScrolledChart(c,t,e)}updateScrolledChart(t,e,i){const o=this.w;this.ctx.updateHelpers._updateOptions(t,!1,!1),"function"==typeof o.config.chart.events.scrolled&&o.config.chart.events.scrolled(this.ctx,{xaxis:{min:e,max:i}})}}