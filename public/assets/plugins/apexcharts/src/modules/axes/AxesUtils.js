import Formatters from"../Formatters";import Graphics from"../Graphics";import CoreUtils from"../CoreUtils";import DateTime from"../../utils/DateTime";export default class AxesUtils{constructor(t){this.ctx=t,this.w=t.w}getLabel(t,e,s,i,r=[],a="12px",o=!0){const l=this.w;let n=void 0===t[i]?"":t[i],c=n,x=l.globals.xLabelFormatter,h=l.config.xaxis.labels.formatter,f=!1,g=new Formatters(this.ctx),d=n;o&&(c=g.xLabelFormat(x,n,d,{i,dateFormatter:new DateTime(this.ctx).formatDate,w:l}),void 0!==h&&(c=h(n,t[i],{i,dateFormatter:new DateTime(this.ctx).formatDate,w:l})));e.length>0?(f=(t=>{let s=null;return e.forEach((t=>{"month"===t.unit?s="year":"day"===t.unit?s="month":"hour"===t.unit?s="day":"minute"===t.unit&&(s="hour")})),s===t})(e[i].unit),s=e[i].position,c=e[i].value):"datetime"===l.config.xaxis.type&&void 0===h&&(c=""),void 0===c&&(c=""),c=Array.isArray(c)?c:c.toString();let m=new Graphics(this.ctx),u={};u=l.globals.rotateXLabels&&o?m.getTextRects(c,parseInt(a,10),null,`rotate(${l.config.xaxis.labels.rotate} 0 0)`,!1):m.getTextRects(c,parseInt(a,10));const b=!l.config.xaxis.labels.showDuplicates&&this.ctx.timeScale;return!Array.isArray(c)&&("NaN"===String(c)||r.indexOf(c)>=0&&b)&&(c=""),{x:s,text:c,textRect:u,isBold:f}}checkLabelBasedOnTickamount(t,e,s){const i=this.w;let r=i.config.xaxis.tickAmount;return"dataPoints"===r&&(r=Math.round(i.globals.gridWidth/120)),r>s||t%Math.round(s/(r+1))==0||(e.text=""),e}checkForOverflowingLabels(t,e,s,i,r){const a=this.w;if(0===t&&a.globals.skipFirstTimelinelabel&&(e.text=""),t===s-1&&a.globals.skipLastTimelinelabel&&(e.text=""),a.config.xaxis.labels.hideOverlappingLabels&&i.length>0){const t=r[r.length-1];e.x<t.textRect.width/(a.globals.rotateXLabels?Math.abs(a.config.xaxis.labels.rotate)/12:1.01)+t.x&&(e.text="")}return e}checkForReversedLabels(t,e){const s=this.w;return s.config.yaxis[t]&&s.config.yaxis[t].reversed&&e.reverse(),e}yAxisAllSeriesCollapsed(t){const e=this.w.globals;return!e.seriesYAxisMap[t].some((t=>-1===e.collapsedSeriesIndices.indexOf(t)))}translateYAxisIndex(t){const e=this.w,s=e.globals,i=e.config.yaxis;return s.series.length>i.length||i.some((t=>Array.isArray(t.seriesName)))?t:s.seriesYAxisReverseMap[t]}isYAxisHidden(t){const e=this.w,s=e.config.yaxis[t];if(!s.show||this.yAxisAllSeriesCollapsed(t))return!0;if(!s.showForNullSeries){const s=e.globals.seriesYAxisMap[t],i=new CoreUtils(this.ctx);return s.every((t=>i.isSeriesNull(t)))}return!1}getYAxisForeColor(t,e){const s=this.w;return Array.isArray(t)&&s.globals.yAxisScale[e]&&this.ctx.theme.pushExtraColors(t,s.globals.yAxisScale[e].result.length,!1),t}drawYAxisTicks(t,e,s,i,r,a,o){let l=this.w,n=new Graphics(this.ctx),c=l.globals.translateY+l.config.yaxis[r].labels.offsetY;if(l.globals.isBarHorizontal?c=0:"heatmap"===l.config.chart.type&&(c+=a/2),i.show&&e>0){!0===l.config.yaxis[r].opposite&&(t+=i.width);for(let r=e;r>=0;r--){let e=n.drawLine(t+s.offsetX-i.width+i.offsetX,c+i.offsetY,t+s.offsetX+i.offsetX,c+i.offsetY,i.color);o.add(e),c+=a}}}}