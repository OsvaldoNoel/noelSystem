import Utils from"../utils/Utils";export default class Scales{constructor(e){this.ctx=e,this.w=e.w}niceScale(e,i,a=0){const s=1e-11,t=this.w,l=t.globals;let r,o,n,h;l.isBarHorizontal?(r=t.config.xaxis,o=Math.max((l.svgWidth-100)/25,2)):(r=t.config.yaxis[a],o=Math.max((l.svgHeight-100)/15,2)),n=void 0!==r.min&&null!==r.min,h=void 0!==r.max&&null!==r.min;let c=void 0!==r.stepSize&&null!==r.stepSize,m=void 0!==r.tickAmount&&null!==r.tickAmount,u=m?r.tickAmount:r.forceNiceScale?l.niceScaleDefaultTicks[Math.min(Math.round(o/2),l.niceScaleDefaultTicks.length-1)]:10;if(l.isMultipleYAxis&&!m&&l.multiAxisTickAmount>0&&(u=l.multiAxisTickAmount,m=!0),u="dataPoints"===u?l.dataPoints-1:Math.abs(Math.round(u)),(e===Number.MIN_VALUE&&0===i||!Utils.isNumber(e)&&!Utils.isNumber(i)||e===Number.MIN_VALUE&&i===-Number.MAX_VALUE)&&(e=Utils.isNumber(r.min)?r.min:0,i=Utils.isNumber(r.max)?r.max:e+u,l.allSeriesCollapsed=!1),e>i){console.warn("axis.min cannot be greater than axis.max: swapping min and max");let a=i;i=e,e=a}else e===i&&(e=0===e?0:e-1,i=0===i?2:i+1);let M=[];u<1&&(u=1);let x=u,f=Math.abs(i-e);if(r.forceNiceScale){let a=.15;!n&&e>0&&e/f<a&&(e=0,n=!0),!h&&i<0&&-i/f<a&&(i=0,h=!0),f=Math.abs(i-e)}let p=f/x,g=p,A=Math.floor(Math.log10(g)),d=Math.pow(10,A),S=Math.ceil(g/d);if(S=l.niceScaleAllowedMagMsd[0===l.yValueDecimal?0:1][S],g=S*d,p=g,l.isBarHorizontal&&r.stepSize&&"datetime"!==r.type?(p=r.stepSize,c=!0):c&&(p=r.stepSize),c&&r.forceNiceScale){let e=Math.floor(Math.log10(p));p*=Math.pow(10,A-e)}if(n&&h){let e=f/x;if(m)if(c)if(0!=Utils.mod(f,p)){let i=Utils.getGCD(p,e);p=e/i<10?i:e}else 0==Utils.mod(p,e)?p=e:(e=p,m=!1);else p=e;else if(c)0==Utils.mod(f,p)?e=p:p=e;else if(0==Utils.mod(f,p))e=p;else{x=Math.ceil(f/p),e=f/x;let i=Utils.getGCD(f,p);f/i<o&&(e=i),p=e}x=Math.round(f/p)}else{if(n||h){if(h)if(m)e=i-p*x;else{let a=e;e=p*Math.floor(e/p),Math.abs(i-e)/Utils.getGCD(f,p)>o&&(e=i-p*u,e+=p*Math.floor((a-e)/p))}else if(n)if(m)i=e+p*x;else{let a=i;i=p*Math.ceil(i/p),Math.abs(i-e)/Utils.getGCD(f,p)>o&&(i=e+p*u,i+=p*Math.ceil((a-i)/p))}}else if(m){let a=p/(i-e>i?1:2),s=a*Math.floor(e/a);Math.abs(s-e)<=a/2?i=(e=s)+p*x:e=(i=a*Math.ceil(i/a))-p*x}else e=p*Math.floor(e/p),i=p*Math.ceil(i/p);f=Math.abs(i-e),p=Utils.getGCD(f,p),x=Math.round(f/p)}if(m||n||h||(x=Math.ceil((f-s)/(p+s)),x>16&&Utils.getPrimeFactors(x).length<2&&x++),!m&&r.forceNiceScale&&0===l.yValueDecimal&&x>f&&(x=f,p=Math.round(f/x)),x>o&&(!m&&!c||r.forceNiceScale)){let e=Utils.getPrimeFactors(x),i=e.length-1,a=x;e:for(var b=0;b<i;b++)for(var N=0;N<=i-b;N++){let s=Math.min(N+b,i),t=a,l=1;for(var y=N;y<=s;y++)l*=e[y];if(t/=l,t<o){a=t;break e}}p=a===x?f:f/a,x=Math.round(f/p)}l.isMultipleYAxis&&0==l.multiAxisTickAmount&&l.ignoreYAxisIndexes.indexOf(a)<0&&(l.multiAxisTickAmount=x);let U=e-p,E=p*s;do{U+=p,M.push(Utils.stripNumber(U,7))}while(i-U>E);return{result:M,niceMin:M[0],niceMax:M[M.length-1]}}linearScale(e,i,a=10,s=0,t=void 0){let l=Math.abs(i-e);"dataPoints"===(a=this._adjustTicksForSmallRange(a,s,l))&&(a=this.w.globals.dataPoints-1),t||(t=l/a),a===Number.MAX_VALUE&&(a=5,t=1);let r=[],o=e;for(;a>=0;)r.push(o),o+=t,a-=1;return{result:r,niceMin:r[0],niceMax:r[r.length-1]}}logarithmicScaleNice(e,i,a){i<=0&&(i=Math.max(e,a)),e<=0&&(e=Math.min(i,a));const s=[],t=Math.ceil(Math.log(i)/Math.log(a)+1);for(let i=Math.floor(Math.log(e)/Math.log(a));i<t;i++)s.push(Math.pow(a,i));return{result:s,niceMin:s[0],niceMax:s[s.length-1]}}logarithmicScale(e,i,a){i<=0&&(i=Math.max(e,a)),e<=0&&(e=Math.min(i,a));const s=[],t=Math.log(i)/Math.log(a),l=Math.log(e)/Math.log(a),r=t-l,o=Math.round(r),n=r/o;for(let e=0,i=l;e<o;e++,i+=n)s.push(Math.pow(a,i));return s.push(Math.pow(a,t)),{result:s,niceMin:e,niceMax:i}}_adjustTicksForSmallRange(e,i,a){let s=e;if(void 0!==i&&this.w.config.yaxis[i].labels.formatter&&void 0===this.w.config.yaxis[i].tickAmount){const e=Number(this.w.config.yaxis[i].labels.formatter(1));Utils.isNumber(e)&&0===this.w.globals.yValueDecimal&&(s=Math.ceil(a))}return s<e?s:e}setYScaleForIndex(e,i,a){const s=this.w.globals,t=this.w.config;let l=s.isBarHorizontal?t.xaxis:t.yaxis[e];void 0===s.yAxisScale[e]&&(s.yAxisScale[e]=[]);let r=Math.abs(a-i);l.logarithmic&&r<=5&&(s.invalidLogScale=!0),l.logarithmic&&r>5?(s.allSeriesCollapsed=!1,s.yAxisScale[e]=l.forceNiceScale?this.logarithmicScaleNice(i,a,l.logBase):this.logarithmicScale(i,a,l.logBase)):a!==-Number.MAX_VALUE&&Utils.isNumber(a)&&i!==Number.MAX_VALUE&&Utils.isNumber(i)?(s.allSeriesCollapsed=!1,s.yAxisScale[e]=this.niceScale(i,a,e)):s.yAxisScale[e]=this.niceScale(Number.MIN_VALUE,0,e)}setXScale(e,i){const a=this.w,s=a.globals;let t=Math.abs(i-e);return i!==-Number.MAX_VALUE&&Utils.isNumber(i)?s.xAxisScale=this.linearScale(e,i,a.config.xaxis.tickAmount?a.config.xaxis.tickAmount:t<10&&t>1?t+1:10,0,a.config.xaxis.stepSize):s.xAxisScale=this.linearScale(0,10,10),s.xAxisScale}setSeriesYAxisMappings(){const e=this.w.globals,i=this.w.config;let a=[],s=[],t=[],l=e.series.length>i.yaxis.length||i.yaxis.some((e=>Array.isArray(e.seriesName)));i.series.forEach(((e,i)=>{t.push(i),s.push(null)})),i.yaxis.forEach(((e,i)=>{a[i]=[]}));let r=[];i.yaxis.forEach(((e,s)=>{let o=!1;if(e.seriesName){let r=[];Array.isArray(e.seriesName)?r=e.seriesName:r.push(e.seriesName),r.forEach((e=>{i.series.forEach(((i,r)=>{if(i.name===e){let e=r;s===r||l?!l||t.indexOf(r)>-1?a[s].push([s,r]):console.warn("Series '"+i.name+"' referenced more than once in what looks like the new style. That is, when using either seriesName: [], or when there are more series than yaxes."):(a[r].push([r,s]),e=s),o=!0,e=t.indexOf(e),-1!==e&&t.splice(e,1)}}))}))}o||r.push(s)})),a=a.map(((e,i)=>{let a=[];return e.forEach((e=>{s[e[1]]=e[0],a.push(e[1])})),a}));let o=i.yaxis.length-1;for(let e=0;e<r.length&&(o=r[e],a[o]=[],t);e++){let e=t[0];t.shift(),a[o].push(e),s[e]=o}t.forEach((e=>{a[o].push(e),s[e]=o})),e.seriesYAxisMap=a.map((e=>e)),e.seriesYAxisReverseMap=s.map((e=>e))}scaleMultipleYAxes(){const e=this.w.config,i=this.w.globals;this.setSeriesYAxisMappings();let a=i.seriesYAxisMap,s=i.minYArr,t=i.maxYArr;i.allSeriesCollapsed=!0,i.barGroups=[],a.forEach(((a,l)=>{let r=[];if(a.forEach((i=>{let a=e.series[i].group;r.indexOf(a)<0&&r.push(a)})),a.length>0){let o,n,h=Number.MAX_VALUE,c=-Number.MAX_VALUE,m=h,u=c;if(e.chart.stacked){let s=i.seriesX[a[0]],t=[],M=[],x=[];r.forEach((()=>{t.push(s.map((()=>Number.MIN_VALUE))),M.push(s.map((()=>Number.MIN_VALUE))),x.push(s.map((()=>Number.MIN_VALUE)))}));for(let s=0;s<a.length;s++){!o&&e.series[a[s]].type&&(o=e.series[a[s]].type);let h=a[s];n=e.series[h].group?e.series[h].group:"axis-".concat(l),!(i.collapsedSeriesIndices.indexOf(h)<0&&i.ancillaryCollapsedSeriesIndices.indexOf(h)<0)||(i.allSeriesCollapsed=!1,r.forEach(((a,s)=>{if(e.series[h].group===a)for(let e=0;e<i.series[h].length;e++){let a=i.series[h][e];a>=0?M[s][e]+=a:x[s][e]+=a,t[s][e]+=a,m=Math.min(m,a),u=Math.max(u,a)}}))),"bar"!==o&&"column"!==o||i.barGroups.push(n)}o||(o=e.chart.type),"bar"===o||"column"===o?r.forEach(((e,i)=>{h=Math.min(h,Math.min.apply(null,x[i])),c=Math.max(c,Math.max.apply(null,M[i]))})):(r.forEach(((e,i)=>{m=Math.min(m,Math.min.apply(null,t[i])),u=Math.max(u,Math.max.apply(null,t[i]))})),h=m,c=u),h===Number.MIN_VALUE&&c===Number.MIN_VALUE&&(c=-Number.MAX_VALUE)}else for(let e=0;e<a.length;e++){let l=a[e];h=Math.min(h,s[l]),c=Math.max(c,t[l]),!(i.collapsedSeriesIndices.indexOf(l)<0&&i.ancillaryCollapsedSeriesIndices.indexOf(l)<0)||(i.allSeriesCollapsed=!1)}void 0!==e.yaxis[l].min&&(h="function"==typeof e.yaxis[l].min?e.yaxis[l].min(h):e.yaxis[l].min),void 0!==e.yaxis[l].max&&(c="function"==typeof e.yaxis[l].max?e.yaxis[l].max(c):e.yaxis[l].max),i.barGroups=i.barGroups.filter(((e,i,a)=>a.indexOf(e)===i)),this.setYScaleForIndex(l,h,c),a.forEach((e=>{s[e]=i.yAxisScale[l].niceMin,t[e]=i.yAxisScale[l].niceMax}))}else this.setYScaleForIndex(l,0,-Number.MAX_VALUE)}))}}