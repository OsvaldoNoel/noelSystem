import Graphics from"./Graphics";import Utils from"../utils/Utils";class Fill{constructor(e){this.ctx=e,this.w=e.w,this.opts=null,this.seriesIndex=0}clippedImgArea(e){let i=this.w,t=i.config,r=parseInt(i.globals.gridWidth,10),l=parseInt(i.globals.gridHeight,10),s=r>l?r:l,o=e.image,a=0,n=0;void 0===e.width&&void 0===e.height?void 0!==t.fill.image.width&&void 0!==t.fill.image.height?(a=t.fill.image.width+1,n=t.fill.image.height):(a=s+1,n=s):(a=e.width,n=e.height);let d=document.createElementNS(i.globals.SVGNS,"pattern");Graphics.setAttrs(d,{id:e.patternID,patternUnits:e.patternUnits?e.patternUnits:"userSpaceOnUse",width:a+"px",height:n+"px"});let g=document.createElementNS(i.globals.SVGNS,"image");d.appendChild(g),g.setAttributeNS(window.SVG.xlink,"href",o),Graphics.setAttrs(g,{x:0,y:0,preserveAspectRatio:"none",width:a+"px",height:n+"px"}),g.style.opacity=e.opacity,i.globals.dom.elDefs.node.appendChild(d)}getSeriesIndex(e){const i=this.w,t=i.config.chart.type;return("bar"===t||"rangeBar"===t)&&i.config.plotOptions.bar.distributed||"heatmap"===t||"treemap"===t?this.seriesIndex=e.seriesNumber:this.seriesIndex=e.seriesNumber%i.globals.series.length,this.seriesIndex}fillPath(e){let i=this.w;this.opts=e;let t,r,l,s=this.w.config;this.seriesIndex=this.getSeriesIndex(e);let o=this.getFillColors()[this.seriesIndex];void 0!==i.globals.seriesColors[this.seriesIndex]&&(o=i.globals.seriesColors[this.seriesIndex]),"function"==typeof o&&(o=o({seriesIndex:this.seriesIndex,dataPointIndex:e.dataPointIndex,value:e.value,w:i}));let a=e.fillType?e.fillType:this.getFillType(this.seriesIndex),n=Array.isArray(s.fill.opacity)?s.fill.opacity[this.seriesIndex]:s.fill.opacity;e.color&&(o=e.color),o||(o="#fff",console.warn("undefined color - ApexCharts"));let d=o;if(-1===o.indexOf("rgb")?o.length<9&&(d=Utils.hexToRgba(o,n)):o.indexOf("rgba")>-1&&(n=Utils.getOpacityFromRGBA(o)),e.opacity&&(n=e.opacity),"pattern"===a&&(r=this.handlePatternFill({fillConfig:e.fillConfig,patternFill:r,fillColor:o,fillOpacity:n,defaultColor:d})),"gradient"===a&&(l=this.handleGradientFill({fillConfig:e.fillConfig,fillColor:o,fillOpacity:n,i:this.seriesIndex})),"image"===a){let r=s.fill.image.src,l=e.patternID?e.patternID:"";this.clippedImgArea({opacity:n,image:Array.isArray(r)?e.seriesNumber<r.length?r[e.seriesNumber]:r[0]:r,width:e.width?e.width:void 0,height:e.height?e.height:void 0,patternUnits:e.patternUnits,patternID:`pattern${i.globals.cuid}${e.seriesNumber+1}${l}`}),t=`url(#pattern${i.globals.cuid}${e.seriesNumber+1}${l})`}else t="gradient"===a?l:"pattern"===a?r:d;return e.solid&&(t=d),t}getFillType(e){const i=this.w;return Array.isArray(i.config.fill.type)?i.config.fill.type[e]:i.config.fill.type}getFillColors(){const e=this.w,i=e.config,t=this.opts;let r=[];return e.globals.comboCharts?"line"===e.config.series[this.seriesIndex].type?Array.isArray(e.globals.stroke.colors)?r=e.globals.stroke.colors:r.push(e.globals.stroke.colors):Array.isArray(e.globals.fill.colors)?r=e.globals.fill.colors:r.push(e.globals.fill.colors):"line"===i.chart.type?Array.isArray(e.globals.stroke.colors)?r=e.globals.stroke.colors:r.push(e.globals.stroke.colors):Array.isArray(e.globals.fill.colors)?r=e.globals.fill.colors:r.push(e.globals.fill.colors),void 0!==t.fillColors&&(r=[],Array.isArray(t.fillColors)?r=t.fillColors.slice():r.push(t.fillColors)),r}handlePatternFill({fillConfig:e,patternFill:i,fillColor:t,fillOpacity:r,defaultColor:l}){let s=this.w.config.fill;e&&(s=e);const o=this.opts;let a=new Graphics(this.ctx),n=Array.isArray(s.pattern.strokeWidth)?s.pattern.strokeWidth[this.seriesIndex]:s.pattern.strokeWidth,d=t;if(Array.isArray(s.pattern.style))if(void 0!==s.pattern.style[o.seriesNumber]){i=a.drawPattern(s.pattern.style[o.seriesNumber],s.pattern.width,s.pattern.height,d,n,r)}else i=l;else i=a.drawPattern(s.pattern.style,s.pattern.width,s.pattern.height,d,n,r);return i}handleGradientFill({fillColor:e,fillOpacity:i,fillConfig:t,i:r}){let l=this.w.config.fill;t&&(l={...l,...t});const s=this.opts;let o,a=new Graphics(this.ctx),n=new Utils,d=l.gradient.type,g=e,h=void 0===l.gradient.opacityFrom?i:Array.isArray(l.gradient.opacityFrom)?l.gradient.opacityFrom[r]:l.gradient.opacityFrom;g.indexOf("rgba")>-1&&(h=Utils.getOpacityFromRGBA(g));let p=void 0===l.gradient.opacityTo?i:Array.isArray(l.gradient.opacityTo)?l.gradient.opacityTo[r]:l.gradient.opacityTo;if(void 0===l.gradient.gradientToColors||0===l.gradient.gradientToColors.length)o="dark"===l.gradient.shade?n.shadeColor(-1*parseFloat(l.gradient.shadeIntensity),e.indexOf("rgb")>-1?Utils.rgb2hex(e):e):n.shadeColor(parseFloat(l.gradient.shadeIntensity),e.indexOf("rgb")>-1?Utils.rgb2hex(e):e);else if(l.gradient.gradientToColors[s.seriesNumber]){const e=l.gradient.gradientToColors[s.seriesNumber];o=e,e.indexOf("rgba")>-1&&(p=Utils.getOpacityFromRGBA(e))}else o=e;if(l.gradient.gradientFrom&&(g=l.gradient.gradientFrom),l.gradient.gradientTo&&(o=l.gradient.gradientTo),l.gradient.inverseColors){let e=g;g=o,o=e}return g.indexOf("rgb")>-1&&(g=Utils.rgb2hex(g)),o.indexOf("rgb")>-1&&(o=Utils.rgb2hex(o)),a.drawGradient(d,g,o,h,p,s.size,l.gradient.stops,l.gradient.colorStops,r)}}export default Fill;