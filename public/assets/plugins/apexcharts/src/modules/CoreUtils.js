class CoreUtils{constructor(e){this.ctx=e,this.w=e.w}static checkComboSeries(e,s){let t=!1,i=0,a=0;return void 0===s&&(s="line"),e.length&&void 0!==e[0].type&&e.forEach((e=>{"bar"!==e.type&&"column"!==e.type&&"candlestick"!==e.type&&"boxPlot"!==e.type||i++,void 0!==e.type&&e.type!==s&&a++})),a>0&&(t=!0),{comboBarCount:i,comboCharts:t}}getStackedSeriesTotals(e=[]){const s=this.w;let t=[];if(0===s.globals.series.length)return t;for(let i=0;i<s.globals.series[s.globals.maxValsInArrayIndex].length;i++){let a=0;for(let t=0;t<s.globals.series.length;t++)void 0!==s.globals.series[t][i]&&-1===e.indexOf(t)&&(a+=s.globals.series[t][i]);t.push(a)}return t}getSeriesTotalByIndex(e=null){return null===e?this.w.config.series.reduce(((e,s)=>e+s),0):this.w.globals.series[e].reduce(((e,s)=>e+s),0)}getStackedSeriesTotalsByGroups(){const e=this.w;let s=[];return e.globals.seriesGroups.forEach((t=>{let i=[];e.config.series.forEach(((s,a)=>{t.indexOf(e.globals.seriesNames[a])>-1&&i.push(a)}));const a=e.globals.series.map(((e,s)=>-1===i.indexOf(s)?s:-1)).filter((e=>-1!==e));s.push(this.getStackedSeriesTotals(a))})),s}setSeriesYAxisMappings(){const e=this.w.globals,s=this.w.config;let t=[],i=[],a=[],r=e.series.length>s.yaxis.length||s.yaxis.some((e=>Array.isArray(e.seriesName)));s.series.forEach(((e,s)=>{a.push(s),i.push(null)})),s.yaxis.forEach(((e,s)=>{t[s]=[]}));let l=[];s.yaxis.forEach(((e,i)=>{let o=!1;if(e.seriesName){let l=[];Array.isArray(e.seriesName)?l=e.seriesName:l.push(e.seriesName),l.forEach((e=>{s.series.forEach(((s,l)=>{if(s.name===e){let e=l;i===l||r?!r||a.indexOf(l)>-1?t[i].push([i,l]):console.warn("Series '"+s.name+"' referenced more than once in what looks like the new style. That is, when using either seriesName: [], or when there are more series than yaxes."):(t[l].push([l,i]),e=i),o=!0,e=a.indexOf(e),-1!==e&&a.splice(e,1)}}))}))}o||l.push(i)})),t=t.map(((e,s)=>{let t=[];return e.forEach((e=>{i[e[1]]=e[0],t.push(e[1])})),t}));let o=s.yaxis.length-1;for(let e=0;e<l.length&&(o=l[e],t[o]=[],a);e++){let e=a[0];a.shift(),t[o].push(e),i[e]=o}a.forEach((e=>{t[o].push(e),i[e]=o})),e.seriesYAxisMap=t.map((e=>e)),e.seriesYAxisReverseMap=i.map((e=>e)),e.seriesYAxisMap.forEach(((e,t)=>{e.forEach((e=>{s.series[e]&&void 0===s.series[e].group&&(s.series[e].group="apexcharts-axis-".concat(t.toString()))}))}))}isSeriesNull(e=null){let s=[];return s=null===e?this.w.config.series.filter((e=>null!==e)):this.w.config.series[e].data.filter((e=>null!==e)),0===s.length}seriesHaveSameValues(e){return this.w.globals.series[e].every(((e,s,t)=>e===t[0]))}getCategoryLabels(e){const s=this.w;let t=e.slice();return s.config.xaxis.convertedCatToNumeric&&(t=e.map(((e,t)=>s.config.xaxis.labels.formatter(e-s.globals.minX+1)))),t}getLargestSeries(){const e=this.w;e.globals.maxValsInArrayIndex=e.globals.series.map((e=>e.length)).indexOf(Math.max.apply(Math,e.globals.series.map((e=>e.length))))}getLargestMarkerSize(){const e=this.w;let s=0;return e.globals.markers.size.forEach((e=>{s=Math.max(s,e)})),e.config.markers.discrete&&e.config.markers.discrete.length&&e.config.markers.discrete.forEach((e=>{s=Math.max(s,e.size)})),s>0&&(s+=e.config.markers.hover.sizeOffset+1),e.globals.markers.largestSize=s,s}getSeriesTotals(){const e=this.w;e.globals.seriesTotals=e.globals.series.map(((e,s)=>{let t=0;if(Array.isArray(e))for(let s=0;s<e.length;s++)t+=e[s];else t+=e;return t}))}getSeriesTotalsXRange(e,s){const t=this.w;return t.globals.series.map(((i,a)=>{let r=0;for(let l=0;l<i.length;l++)t.globals.seriesX[a][l]>e&&t.globals.seriesX[a][l]<s&&(r+=i[l]);return r}))}getPercentSeries(){const e=this.w;e.globals.seriesPercent=e.globals.series.map(((s,t)=>{let i=[];if(Array.isArray(s))for(let t=0;t<s.length;t++){let a=e.globals.stackedSeriesTotals[t],r=0;a&&(r=100*s[t]/a),i.push(r)}else{let t=100*s/e.globals.seriesTotals.reduce(((e,s)=>e+s),0);i.push(t)}return i}))}getCalculatedRatios(){let e=this.w,s=e.globals,t=[],i=0,a=0,r=0,l=0,o=[],n=.1,g=0;if(s.yRange=[],s.isMultipleYAxis)for(let e=0;e<s.minYArr.length;e++)s.yRange.push(Math.abs(s.minYArr[e]-s.maxYArr[e])),o.push(0);else s.yRange.push(Math.abs(s.minY-s.maxY));s.xRange=Math.abs(s.maxX-s.minX),s.zRange=Math.abs(s.maxZ-s.minZ);for(let e=0;e<s.yRange.length;e++)t.push(s.yRange[e]/s.gridHeight);if(a=s.xRange/s.gridWidth,i=s.yRange/s.gridWidth,r=s.xRange/s.gridHeight,l=s.zRange/s.gridHeight*16,l||(l=1),s.minY!==Number.MIN_VALUE&&0!==Math.abs(s.minY)&&(s.hasNegs=!0),e.globals.seriesYAxisReverseMap.length>0){let r=(s,i)=>{let a=e.config.yaxis[e.globals.seriesYAxisReverseMap[i]],r=s<0?-1:1;return s=Math.abs(s),a.logarithmic&&(s=this.getBaseLog(a.logBase,s)),-r*s/t[i]};if(s.isMultipleYAxis){o=[];for(let e=0;e<t.length;e++)o.push(r(s.minYArr[e],e))}else o=[],o.push(r(s.minY,0)),s.minY!==Number.MIN_VALUE&&0!==Math.abs(s.minY)&&(n=-s.minY/i,g=s.minX/a)}else o=[],o.push(0),n=0,g=0;return{yRatio:t,invertedYRatio:i,zRatio:l,xRatio:a,invertedXRatio:r,baseLineInvertedY:n,baseLineY:o,baseLineX:g}}getLogSeries(e){const s=this.w;return s.globals.seriesLog=e.map(((e,t)=>{let i=s.globals.seriesYAxisReverseMap[t];return s.config.yaxis[i]&&s.config.yaxis[i].logarithmic?e.map((e=>null===e?null:this.getLogVal(s.config.yaxis[i].logBase,e,t))):e})),s.globals.invalidLogScale?e:s.globals.seriesLog}getBaseLog(e,s){return Math.log(s)/Math.log(e)}getLogVal(e,s,t){if(s<=0)return 0;const i=this.w,a=0===i.globals.minYArr[t]?-1:this.getBaseLog(e,i.globals.minYArr[t]),r=(0===i.globals.maxYArr[t]?0:this.getBaseLog(e,i.globals.maxYArr[t]))-a;if(s<1)return s/r;return(this.getBaseLog(e,s)-a)/r}getLogYRatios(e){const s=this.w,t=this.w.globals;return t.yLogRatio=e.slice(),t.logYRange=t.yRange.map(((e,i)=>{let a=s.globals.seriesYAxisReverseMap[i];if(s.config.yaxis[a]&&this.w.config.yaxis[a].logarithmic){let e=-Number.MAX_VALUE,a=Number.MIN_VALUE,r=1;return t.seriesLog.forEach(((t,i)=>{t.forEach((t=>{s.config.yaxis[i]&&s.config.yaxis[i].logarithmic&&(e=Math.max(t,e),a=Math.min(t,a))}))})),r=Math.pow(t.yRange[i],Math.abs(a-e)/t.yRange[i]),t.yLogRatio[i]=r/t.gridHeight,r}})),t.invalidLogScale?e.slice():t.yLogRatio}static extendArrayProps(e,s,t){return s?.yaxis&&(s=e.extendYAxis(s,t)),s?.annotations&&(s.annotations.yaxis&&(s=e.extendYAxisAnnotations(s)),s?.annotations?.xaxis&&(s=e.extendXAxisAnnotations(s)),s?.annotations?.points&&(s=e.extendPointAnnotations(s))),s}drawSeriesByGroup(e,s,t,i){let a=this.w,r=[];return e.series.length>0&&s.forEach((s=>{let l=[],o=[];e.i.forEach(((t,i)=>{a.config.series[t].group===s&&(l.push(e.series[i]),o.push(t))})),l.length>0&&r.push(i.draw(l,t,o))})),r}}export default CoreUtils;