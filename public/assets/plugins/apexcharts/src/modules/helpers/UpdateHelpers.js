import Defaults from"../settings/Defaults";import Config from"../settings/Config";import CoreUtils from"../CoreUtils";import Graphics from"../Graphics";import Utils from"../../utils/Utils";export default class UpdateHelpers{constructor(s){this.ctx=s,this.w=s.w}_updateOptions(s,e=!1,i=!0,t=!0,a=!1){return new Promise((l=>{let o=[this.ctx];t&&(o=this.ctx.getSyncedCharts()),this.ctx.w.globals.isExecCalled&&(o=[this.ctx],this.ctx.w.globals.isExecCalled=!1),o.forEach(((t,r)=>{let n=t.w;if(n.globals.shouldAnimate=i,e||(n.globals.resized=!0,n.globals.dataChanged=!0,i&&t.series.getPreviousPaths()),s&&"object"==typeof s&&(t.config=new Config(s),s=CoreUtils.extendArrayProps(t.config,s,n),t.w.globals.chartID!==this.ctx.w.globals.chartID&&delete s.series,n.config=Utils.extend(n.config,s),a&&(n.globals.lastXAxis=s.xaxis?Utils.clone(s.xaxis):[],n.globals.lastYAxis=s.yaxis?Utils.clone(s.yaxis):[],n.globals.initialConfig=Utils.extend({},n.config),n.globals.initialSeries=Utils.clone(n.config.series),s.series))){for(let s=0;s<n.globals.collapsedSeriesIndices.length;s++){let e=n.config.series[n.globals.collapsedSeriesIndices[s]];n.globals.collapsedSeries[s].data=n.globals.axisCharts?e.data.slice():e}for(let s=0;s<n.globals.ancillaryCollapsedSeriesIndices.length;s++){let e=n.config.series[n.globals.ancillaryCollapsedSeriesIndices[s]];n.globals.ancillaryCollapsedSeries[s].data=n.globals.axisCharts?e.data.slice():e}t.series.emptyCollapsedSeries(n.config.series)}return t.update(s).then((()=>{r===o.length-1&&l(t)}))}))}))}_updateSeries(s,e,i=!1){return new Promise((t=>{const a=this.w;let l;return a.globals.shouldAnimate=e,a.globals.dataChanged=!0,e&&this.ctx.series.getPreviousPaths(),a.globals.axisCharts?(l=s.map(((s,e)=>this._extendSeries(s,e))),0===l.length&&(l=[{data:[]}]),a.config.series=l):a.config.series=s.slice(),i&&(a.globals.initialConfig.series=Utils.clone(a.config.series),a.globals.initialSeries=Utils.clone(a.config.series)),this.ctx.update().then((()=>{t(this.ctx)}))}))}_extendSeries(s,e){const i=this.w,t=i.config.series[e];return{...i.config.series[e],name:s.name?s.name:t?.name,color:s.color?s.color:t?.color,type:s.type?s.type:t?.type,group:s.group?s.group:t?.group,data:s.data?s.data:t?.data,zIndex:void 0!==s.zIndex?s.zIndex:e}}toggleDataPointSelection(s,e){const i=this.w;let t=null;const a=`.apexcharts-series[data\\:realIndex='${s}']`;if(i.globals.axisCharts?t=i.globals.dom.Paper.select(`${a} path[j='${e}'], ${a} circle[j='${e}'], ${a} rect[j='${e}']`).members[0]:void 0===e&&(t=i.globals.dom.Paper.select(`${a} path[j='${s}']`).members[0],"pie"!==i.config.chart.type&&"polarArea"!==i.config.chart.type&&"donut"!==i.config.chart.type||this.ctx.pie.pieClicked(s)),!t)return console.warn("toggleDataPointSelection: Element not found"),null;new Graphics(this.ctx).pathMouseDown(t,null);return t.node?t.node:null}forceXAxisUpdate(s){const e=this.w;if(["min","max"].forEach((i=>{void 0!==s.xaxis[i]&&(e.config.xaxis[i]=s.xaxis[i],e.globals.lastXAxis[i]=s.xaxis[i])})),s.xaxis.categories&&s.xaxis.categories.length&&(e.config.xaxis.categories=s.xaxis.categories),e.config.xaxis.convertedCatToNumeric){const e=new Defaults(s);s=e.convertCatToNumericXaxis(s,this.ctx)}return s}forceYAxisUpdate(s){return s.chart&&s.chart.stacked&&"100%"===s.chart.stackType&&(Array.isArray(s.yaxis)?s.yaxis.forEach(((e,i)=>{s.yaxis[i].min=0,s.yaxis[i].max=100})):(s.yaxis.min=0,s.yaxis.max=100)),s}revertDefaultAxisMinMax(s){const e=this.w;let i=e.globals.lastXAxis,t=e.globals.lastYAxis;s&&s.xaxis&&(i=s.xaxis),s&&s.yaxis&&(t=s.yaxis),e.config.xaxis.min=i.min,e.config.xaxis.max=i.max;const a=s=>{void 0!==t[s]&&(e.config.yaxis[s].min=t[s].min,e.config.yaxis[s].max=t[s].max)};e.config.yaxis.map(((s,i)=>{e.globals.zoomed||void 0!==t[i]?a(i):void 0!==this.ctx.opts.yaxis[i]&&(s.min=this.ctx.opts.yaxis[i].min,s.max=this.ctx.opts.yaxis[i].max)}))}}