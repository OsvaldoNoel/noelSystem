import CoreUtils from"../modules/CoreUtils";import Graphics from"../modules/Graphics";import Fill from"../modules/Fill";import DataLabels from"../modules/DataLabels";import Markers from"../modules/Markers";import Scatter from"./Scatter";import Utils from"../utils/Utils";import Helpers from"./common/line/Helpers";import{svgPath,spline}from"../libs/monotone-cubic";class Line{constructor(e,t,s){this.ctx=e,this.w=e.w,this.xyRatios=t,this.pointsChart=!("bubble"!==this.w.config.chart.type&&"scatter"!==this.w.config.chart.type)||s,this.scatter=new Scatter(this.ctx),this.noNegatives=this.w.globals.minX===Number.MAX_VALUE,this.lineHelpers=new Helpers(this),this.markers=new Markers(this.ctx),this.prevSeriesY=[],this.categoryAxisCorrection=0,this.yaxisIndex=0}draw(e,t,s,i){let a=this.w,r=new Graphics(this.ctx),l=a.globals.comboCharts?t:a.config.chart.type,n=r.group({class:`apexcharts-${l}-series apexcharts-plot-series`});const o=new CoreUtils(this.ctx,a);this.yRatio=this.xyRatios.yRatio,this.zRatio=this.xyRatios.zRatio,this.xRatio=this.xyRatios.xRatio,this.baseLineY=this.xyRatios.baseLineY,e=o.getLogSeries(e),this.yRatio=o.getLogYRatios(this.yRatio),this.prevSeriesY=[];let h=[];for(let t=0;t<e.length;t++){e=this.lineHelpers.sameValueSeriesFix(t,e);let r=a.globals.comboCharts?s[t]:t,n=this.yRatio.length>1?r:0;this._initSerieVariables(e,t,r);let o=[],c=[],p=[],d=a.globals.padHorizontal+this.categoryAxisCorrection,g=1,m=[],u=[];this.ctx.series.addCollapsedClassToSeries(this.elSeries,r),a.globals.isXNumeric&&a.globals.seriesX.length>0&&(d=(a.globals.seriesX[r][0]-a.globals.minX)/this.xRatio),p.push(d);let f,x,b,P=d,v=P,y=this.zeroY,A=this.zeroY,k=0;y=this.lineHelpers.determineFirstPrevY({i:t,realIndex:r,series:e,prevY:y,lineYPosition:k,translationsIndex:n}).prevY,"monotoneCubic"===a.config.stroke.curve&&null===e[t][0]?o.push(null):o.push(y),f=y,"rangeArea"===l&&(b=this.lineHelpers.determineFirstPrevY({i:t,realIndex:r,series:i,prevY:A,lineYPosition:k,translationsIndex:n}),A=b.prevY,x=A,c.push(null!==o[0]?A:null));let Y=this._calculatePathsFrom({type:l,series:e,i:t,realIndex:r,translationsIndex:n,prevX:v,prevY:y,prevY2:A}),w=[o[0]],S=[c[0]];const I={type:l,series:e,realIndex:r,translationsIndex:n,i:t,x:d,y:g,pX:P,pY:f,pathsFrom:Y,linePaths:m,areaPaths:u,seriesIndex:s,lineYPosition:k,xArrj:p,yArrj:o,y2Arrj:c,seriesRangeEnd:i};let R=this._iterateOverDataPoints({...I,iterations:"rangeArea"===l?e[t].length-1:void 0,isRangeStart:!0});if("rangeArea"===l){let e=this._calculatePathsFrom({series:i,i:t,realIndex:r,prevX:v,prevY:A}),s=this._iterateOverDataPoints({...I,series:i,xArrj:[d],yArrj:w,y2Arrj:S,pY:x,areaPaths:R.areaPaths,pathsFrom:e,iterations:i[t].length-1,isRangeStart:!1}),a=R.linePaths.length/2;for(let e=0;e<a;e++)R.linePaths[e]=s.linePaths[e+a]+R.linePaths[e];R.linePaths.splice(a),R.pathFromLine=s.pathFromLine+R.pathFromLine}else R.pathFromArea+="z";this._handlePaths({type:l,realIndex:r,i:t,paths:R}),this.elSeries.add(this.elPointsMain),this.elSeries.add(this.elDataLabelsWrap),h.push(this.elSeries)}if(void 0!==a.config.series[0]?.zIndex&&h.sort(((e,t)=>Number(e.node.getAttribute("zIndex"))-Number(t.node.getAttribute("zIndex")))),a.config.chart.stacked)for(let e=h.length-1;e>=0;e--)n.add(h[e]);else for(let e=0;e<h.length;e++)n.add(h[e]);return n}_initSerieVariables(e,t,s){const i=this.w,a=new Graphics(this.ctx);this.xDivision=i.globals.gridWidth/(i.globals.dataPoints-("on"===i.config.xaxis.tickPlacement?1:0)),this.strokeWidth=Array.isArray(i.config.stroke.width)?i.config.stroke.width[s]:i.config.stroke.width;let r=0;this.yRatio.length>1&&(this.yaxisIndex=i.globals.seriesYAxisReverseMap[s],r=s),this.isReversed=i.config.yaxis[this.yaxisIndex]&&i.config.yaxis[this.yaxisIndex].reversed,this.zeroY=i.globals.gridHeight-this.baseLineY[r]-(this.isReversed?i.globals.gridHeight:0)+(this.isReversed?2*this.baseLineY[r]:0),this.areaBottomY=this.zeroY,(this.zeroY>i.globals.gridHeight||"end"===i.config.plotOptions.area.fillTo)&&(this.areaBottomY=i.globals.gridHeight),this.categoryAxisCorrection=this.xDivision/2,this.elSeries=a.group({class:"apexcharts-series",zIndex:void 0!==i.config.series[s].zIndex?i.config.series[s].zIndex:s,seriesName:Utils.escapeString(i.globals.seriesNames[s])}),this.elPointsMain=a.group({class:"apexcharts-series-markers-wrap","data:realIndex":s}),this.elDataLabelsWrap=a.group({class:"apexcharts-datalabels","data:realIndex":s});let l=e[t].length===i.globals.dataPoints;this.elSeries.attr({"data:longestSeries":l,rel:t+1,"data:realIndex":s}),this.appendPathFrom=!0}_calculatePathsFrom({type:e,series:t,i:s,realIndex:i,translationsIndex:a,prevX:r,prevY:l,prevY2:n}){const o=this.w,h=new Graphics(this.ctx);let c,p,d,g;if(null===t[s][0]){for(let e=0;e<t[s].length;e++)if(null!==t[s][e]){r=this.xDivision*e,l=this.zeroY-t[s][e]/this.yRatio[a],c=h.move(r,l),p=h.move(r,this.areaBottomY);break}}else c=h.move(r,l),"rangeArea"===e&&(c=h.move(r,n)+h.line(r,l)),p=h.move(r,this.areaBottomY)+h.line(r,l);if(d=h.move(0,this.zeroY)+h.line(0,this.zeroY),g=h.move(0,this.zeroY)+h.line(0,this.zeroY),o.globals.previousPaths.length>0){const e=this.lineHelpers.checkPreviousPaths({pathFromLine:d,pathFromArea:g,realIndex:i});d=e.pathFromLine,g=e.pathFromArea}return{prevX:r,prevY:l,linePath:c,areaPath:p,pathFromLine:d,pathFromArea:g}}_handlePaths({type:e,realIndex:t,i:s,paths:i}){const a=this.w,r=new Graphics(this.ctx),l=new Fill(this.ctx);this.prevSeriesY.push(i.yArrj),a.globals.seriesXvalues[t]=i.xArrj,a.globals.seriesYvalues[t]=i.yArrj;const n=a.config.forecastDataPoints;if(n.count>0&&"rangeArea"!==e){const e=a.globals.seriesXvalues[t][a.globals.seriesXvalues[t].length-n.count-1],s=r.drawRect(e,0,a.globals.gridWidth,a.globals.gridHeight,0);a.globals.dom.elForecastMask.appendChild(s.node);const i=r.drawRect(0,0,e,a.globals.gridHeight,0);a.globals.dom.elNonForecastMask.appendChild(i.node)}this.pointsChart||a.globals.delayedElements.push({el:this.elPointsMain.node,index:t});const o={i:s,realIndex:t,animationDelay:s,initialSpeed:a.config.chart.animations.speed,dataChangeSpeed:a.config.chart.animations.dynamicAnimation.speed,className:`apexcharts-${e}`};if("area"===e){let e=l.fillPath({seriesNumber:t});for(let t=0;t<i.areaPaths.length;t++){let s=r.renderPaths({...o,pathFrom:i.pathFromArea,pathTo:i.areaPaths[t],stroke:"none",strokeWidth:0,strokeLineCap:null,fill:e});this.elSeries.add(s)}}if(a.config.stroke.show&&!this.pointsChart){let h=null;if("line"===e)h=l.fillPath({seriesNumber:t,i:s});else if("solid"===a.config.stroke.fill.type)h=a.globals.stroke.colors[t];else{const e=a.config.fill;a.config.fill=a.config.stroke.fill,h=l.fillPath({seriesNumber:t,i:s}),a.config.fill=e}for(let s=0;s<i.linePaths.length;s++){let c=h;"rangeArea"===e&&(c=l.fillPath({seriesNumber:t}));const p={...o,pathFrom:i.pathFromLine,pathTo:i.linePaths[s],stroke:h,strokeWidth:this.strokeWidth,strokeLineCap:a.config.stroke.lineCap,fill:"rangeArea"===e?c:"none"};let d=r.renderPaths(p);if(this.elSeries.add(d),d.attr("fill-rule","evenodd"),n.count>0&&"rangeArea"!==e){let e=r.renderPaths(p);e.node.setAttribute("stroke-dasharray",n.dashArray),n.strokeWidth&&e.node.setAttribute("stroke-width",n.strokeWidth),this.elSeries.add(e),e.attr("clip-path",`url(#forecastMask${a.globals.cuid})`),d.attr("clip-path",`url(#nonForecastMask${a.globals.cuid})`)}}}}_iterateOverDataPoints({type:e,series:t,iterations:s,realIndex:i,translationsIndex:a,i:r,x:l,y:n,pX:o,pY:h,pathsFrom:c,linePaths:p,areaPaths:d,seriesIndex:g,lineYPosition:m,xArrj:u,yArrj:f,y2Arrj:x,isRangeStart:b,seriesRangeEnd:P}){const v=this.w;let y=new Graphics(this.ctx),A=this.yRatio,{prevY:k,linePath:Y,areaPath:w,pathFromLine:S,pathFromArea:I}=c;const R=Utils.isNumber(v.globals.minYArr[i])?v.globals.minYArr[i]:v.globals.minY;s||(s=v.globals.dataPoints>1?v.globals.dataPoints-1:v.globals.dataPoints);const F=(e,t)=>t-e/A[a]+2*(this.isReversed?e/A[a]:0);let z=n,L=v.config.chart.stacked&&!v.globals.comboCharts||v.config.chart.stacked&&v.globals.comboCharts&&(!this.w.config.chart.stackOnlyBar||"bar"===this.w.config.series[i]?.type||"column"===this.w.config.series[i]?.type),C=v.config.stroke.curve;Array.isArray(C)&&(C=Array.isArray(g)?C[g[r]]:C[r]);let X,j=0;for(let a=0;a<s;a++){const c=void 0===t[r][a+1]||null===t[r][a+1];if(v.globals.isXNumeric){let e=v.globals.seriesX[i][a+1];void 0===v.globals.seriesX[i][a+1]&&(e=v.globals.seriesX[i][s-1]),l=(e-v.globals.minX)/this.xRatio}else l+=this.xDivision;if(L)if(r>0&&v.globals.collapsedSeries.length<v.config.series.length-1){const e=e=>{for(let t=e;t>0;t--){if(!(v.globals.collapsedSeriesIndices.indexOf(g?.[t]||t)>-1))return t;t--}return 0};m=this.prevSeriesY[e(r-1)][a+1]}else m=this.zeroY;else m=this.zeroY;c?n=F(R,m):(n=F(t[r][a+1],m),"rangeArea"===e&&(z=F(P[r][a+1],m))),u.push(l),!c||"smooth"!==v.config.stroke.curve&&"monotoneCubic"!==v.config.stroke.curve?(f.push(n),x.push(z)):(f.push(null),x.push(null));let A=this.lineHelpers.calculatePoints({series:t,x:l,y:n,realIndex:i,i:r,j:a,prevY:k}),M=this._createPaths({type:e,series:t,i:r,realIndex:i,j:a,x:l,y:n,y2:z,xArrj:u,yArrj:f,y2Arrj:x,pX:o,pY:h,pathState:j,segmentStartX:X,linePath:Y,areaPath:w,linePaths:p,areaPaths:d,curve:C,isRangeStart:b});d=M.areaPaths,p=M.linePaths,o=M.pX,h=M.pY,j=M.pathState,X=M.segmentStartX,w=M.areaPath,Y=M.linePath,!this.appendPathFrom||"monotoneCubic"===C&&"rangeArea"===e||(S+=y.line(l,this.zeroY),I+=y.line(l,this.zeroY)),this.handleNullDataPoints(t,A,r,a,i),this._handleMarkersAndLabels({type:e,pointsPos:A,i:r,j:a,realIndex:i,isRangeStart:b})}return{yArrj:f,xArrj:u,pathFromArea:I,areaPaths:d,pathFromLine:S,linePaths:p,linePath:Y,areaPath:w}}_handleMarkersAndLabels({type:e,pointsPos:t,isRangeStart:s,i,j:a,realIndex:r}){const l=this.w;let n=new DataLabels(this.ctx);if(this.pointsChart)this.scatter.draw(this.elSeries,a,{realIndex:r,pointsPos:t,zRatio:this.zRatio,elParent:this.elPointsMain});else{l.globals.series[i].length>1&&this.elPointsMain.node.classList.add("apexcharts-element-hidden");let e=this.markers.plotChartMarkers(t,r,a+1);null!==e&&this.elPointsMain.add(e)}let o=n.drawDataLabel({type:e,isRangeStart:s,pos:t,i:r,j:a+1});null!==o&&this.elDataLabelsWrap.add(o)}_createPaths({type:e,series:t,i:s,realIndex:i,j:a,x:r,y:l,xArrj:n,yArrj:o,y2:h,y2Arrj:c,pX:p,pY:d,pathState:g,segmentStartX:m,linePath:u,areaPath:f,linePaths:x,areaPaths:b,curve:P,isRangeStart:v}){this.w;let y=new Graphics(this.ctx);const A=this.areaBottomY;let k="rangeArea"===e,Y="rangeArea"===e&&v;switch(P){case"monotoneCubic":let e=v?o:c,i=(e,t)=>e.map(((e,s)=>[e,t[s]])).filter((e=>null!==e[1])),w=e=>{let t=[],s=0;return e.forEach((e=>{null!==e?s++:s>0&&(t.push(s),s=0)})),s>0&&t.push(s),t},S=(e,t)=>{let s=w(e),i=[];for(let e=0,a=0;e<s.length;a+=s[e++])i[e]=spline.slice(t,a,a+s[e]);return i};switch(g){case 0:if(null===e[a+1])break;g=1;case 1:if(!(k?n.length===t[s].length:a===t[s].length-2))break;case 2:const r=v?n:n.slice().reverse(),l=v?e:e.slice().reverse(),o=i(r,l),h=o.length>1?spline.points(o):o;let c=[];k&&(Y?b=o:c=b.reverse());let p=0,d=0;if(S(l,h).forEach((e=>{p++;let t=svgPath(e),s=d;d+=e.length;let i=d-1;Y?u=y.move(o[s][0],o[s][1])+t:k?u=y.move(c[s][0],c[s][1])+y.line(o[s][0],o[s][1])+t+y.line(c[i][0],c[i][1]):(u=y.move(o[s][0],o[s][1])+t,f=u+y.line(o[i][0],A)+y.line(o[s][0],A)+"z",b.push(f)),x.push(u)})),k&&p>1&&!Y){let e=x.slice(p).reverse();x.splice(p),e.forEach((e=>x.push(e)))}g=0}break;case"smooth":let I=.35*(r-p);if(null===t[s][a])g=0;else switch(g){case 0:if(m=p,u=Y?y.move(p,c[a])+y.line(p,d):y.move(p,d),f=y.move(p,d),g=1,a<t[s].length-2){let e=y.curve(p+I,d,r-I,l,r,l);u+=e,f+=e;break}case 1:if(null===t[s][a+1])u+=Y?y.line(p,h):y.move(p,d),f+=y.line(p,A)+y.line(m,A)+"z",x.push(u),b.push(f),g=-1;else{let e=y.curve(p+I,d,r-I,l,r,l);u+=e,f+=e,a>=t[s].length-2&&(Y&&(u+=y.curve(r,l,r,l,r,h)+y.move(r,h)),f+=y.curve(r,l,r,l,r,A)+y.line(m,A)+"z",x.push(u),b.push(f),g=-1)}}p=r,d=l;break;default:let R=(e,t,s)=>{let i=[];switch(e){case"stepline":i=y.line(t,null,"H")+y.line(null,s,"V");break;case"linestep":i=y.line(null,s,"V")+y.line(t,null,"H");break;case"straight":i=y.line(t,s)}return i};if(null===t[s][a])g=0;else switch(g){case 0:if(m=p,u=Y?y.move(p,c[a])+y.line(p,d):y.move(p,d),f=y.move(p,d),g=1,a<t[s].length-2){let e=R(P,r,l);u+=e,f+=e;break}case 1:if(null===t[s][a+1])u+=Y?y.line(p,h):y.move(p,d),f+=y.line(p,A)+y.line(m,A)+"z",x.push(u),b.push(f),g=-1;else{let e=R(P,r,l);u+=e,f+=e,a>=t[s].length-2&&(Y&&(u+=y.line(r,h)),f+=y.line(r,A)+y.line(m,A)+"z",x.push(u),b.push(f),g=-1)}}p=r,d=l}return{linePaths:x,areaPaths:b,pX:p,pY:d,pathState:g,segmentStartX:m,linePath:u,areaPath:f}}handleNullDataPoints(e,t,s,i,a){const r=this.w;if(null===e[s][i]&&r.config.markers.showNullDataPoints||1===e[s].length){let e=this.strokeWidth-r.config.markers.strokeWidth/2;e>0||(e=0);let s=this.markers.plotChartMarkers(t,a,i+1,e,!0);null!==s&&this.elPointsMain.add(s)}}}export default Line;