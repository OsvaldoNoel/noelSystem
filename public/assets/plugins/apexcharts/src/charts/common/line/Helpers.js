import CoreUtils from"../../../modules/CoreUtils";import Utils from"../../../utils/Utils";export default class Helpers{constructor(e){this.w=e.w,this.lineCtx=e}sameValueSeriesFix(e,s){const t=this.w;if("gradient"===t.config.fill.type||"gradient"===t.config.fill.type[e]){if(new CoreUtils(this.lineCtx.ctx,t).seriesHaveSameValues(e)){let t=s[e].slice();t[t.length-1]=t[t.length-1]+1e-6,s[e]=t}}return s}calculatePoints({series:e,realIndex:s,x:t,y:i,i:r,j:l,prevY:o}){let a=this.w,n=[],h=[];if(0===l){let p=this.lineCtx.categoryAxisCorrection+a.config.markers.offsetX;a.globals.isXNumeric&&(p=(a.globals.seriesX[s][0]-a.globals.minX)/this.lineCtx.xRatio+a.config.markers.offsetX),n.push(p),h.push(Utils.isNumber(e[r][0])?o+a.config.markers.offsetY:null),n.push(t+a.config.markers.offsetX),h.push(Utils.isNumber(e[r][l+1])?i+a.config.markers.offsetY:null)}else n.push(t+a.config.markers.offsetX),h.push(Utils.isNumber(e[r][l+1])?i+a.config.markers.offsetY:null);return{x:n,y:h}}checkPreviousPaths({pathFromLine:e,pathFromArea:s,realIndex:t}){let i=this.w;for(let r=0;r<i.globals.previousPaths.length;r++){let l=i.globals.previousPaths[r];("line"===l.type||"area"===l.type)&&l.paths.length>0&&parseInt(l.realIndex,10)===parseInt(t,10)&&("line"===l.type?(this.lineCtx.appendPathFrom=!1,e=i.globals.previousPaths[r].paths[0].d):"area"===l.type&&(this.lineCtx.appendPathFrom=!1,s=i.globals.previousPaths[r].paths[0].d,i.config.stroke.show&&i.globals.previousPaths[r].paths[1]&&(e=i.globals.previousPaths[r].paths[1].d)))}return{pathFromLine:e,pathFromArea:s}}determineFirstPrevY({i:e,realIndex:s,series:t,prevY:i,lineYPosition:r,translationsIndex:l}){let o=this.w,a=o.config.chart.stacked&&!o.globals.comboCharts||o.config.chart.stacked&&o.globals.comboCharts&&(!this.w.config.chart.stackOnlyBar||"bar"===this.w.config.series[s]?.type||"column"===this.w.config.series[s]?.type);if(void 0!==t[e]?.[0])i=(r=a&&e>0?this.lineCtx.prevSeriesY[e-1][0]:this.lineCtx.zeroY)-t[e][0]/this.lineCtx.yRatio[l]+2*(this.lineCtx.isReversed?t[e][0]/this.lineCtx.yRatio[l]:0);else if(a&&e>0&&void 0===t[e][0])for(let s=e-1;s>=0;s--)if(null!==t[s][0]&&void 0!==t[s][0]){i=r=this.lineCtx.prevSeriesY[s][0];break}return{prevY:i,lineYPosition:r}}}