/*! For license information please see config.js.LICENSE.txt */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t(require("../dom/manipulator.js"),require("./index.js")):"function"==typeof define&&define.amd?define(["../dom/manipulator","./index"],t):(e="undefined"!=typeof globalThis?globalThis:e||self).Config=t(e.Manipulator,e.Index)}(this,(function(e,t){"use strict";return class{static get Default(){return{}}static get DefaultType(){return{}}static get NAME(){throw new Error('You have to implement the static method "NAME", for each component!')}_getConfig(e){return e=this._mergeConfigObj(e),e=this._configAfterMerge(e),this._typeCheckConfig(e),e}_configAfterMerge(e){return e}_mergeConfigObj(o,n){const r=t.isElement(n)?e.getDataAttribute(n,"config"):{};return{...this.constructor.Default,..."object"==typeof r?r:{},...t.isElement(n)?e.getDataAttributes(n):{},..."object"==typeof o?o:{}}}_typeCheckConfig(e,o=this.constructor.DefaultType){for(const[n,r]of Object.entries(o)){const o=e[n],i=t.isElement(o)?"element":t.toType(o);if(!new RegExp(r).test(i))throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option "${n}" provided type "${i}" but expected type "${r}".`)}}}}));